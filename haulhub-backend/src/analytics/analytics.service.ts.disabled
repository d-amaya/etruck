import { Injectable } from '@nestjs/common';
import { TripsService } from '../trips/trips.service';
import { UsersService } from '../users/users.service';
import { VehiclesService } from '../vehicles/vehicles.service';
import { Trip, TripStatus, UserRole, User } from '@haulhub/shared';
import { Truck } from '@haulhub/shared';
import { Trailer } from '@haulhub/shared';

export interface FleetOverview {
  drivers: {
    total: number;
    active: number;
    onTrip: number;
    utilization: number;
  };
  vehicles: {
    total: number;
    available: number;
    inUse: number;
    maintenance: number;
    utilization: number;
  };
  trips: {
    total: number;
    completed: number;
    inProgress: number;
    planned: number;
  };
}

export interface TripAnalytics {
  totalTrips: number;
  completedTrips: number;
  totalRevenue: number;
  totalExpenses: number;
  totalProfit: number;
  averageDistance: number;
  averageRevenue: number;
  onTimeDeliveryRate: number;
  fuelEfficiency: number;
}

export interface DriverPerformance {
  driverId: string;
  driverName: string;
  totalTrips: number;
  completedTrips: number;
  totalDistance: number;
  totalRevenue: number;
  averageRevenue: number;
  onTimeDeliveryRate: number;
  utilizationRate: number;
}

export interface VehicleUtilization {
  vehicleId: string;
  vehicleNumber: string;
  totalTrips: number;
  totalDistance: number;
  utilizationRate: number;
  maintenanceCost: number;
  revenueGenerated: number;
  profitability: number;
}

@Injectable()
export class AnalyticsService {
  constructor(
    private readonly tripsService: TripsService,
    private readonly usersService: UsersService,
    private readonly vehiclesService: VehiclesService,
  ) {}

  async getFleetOverview(): Promise<FleetOverview> {
    // TODO: Implement proper data fetching once findAll methods are available
    const trips: Trip[] = [];
    const users: User[] = [];
    const vehicles: any[] = [];

    const drivers = users.filter(user => user.role === UserRole.DRIVER);
    const activeDrivers = drivers.filter(driver => driver.isActive);
    const onTripDrivers = trips
      .filter(trip => trip.status === TripStatus.IN_PROGRESS)
      .map(trip => trip.driverId);
    const uniqueOnTripDrivers = [...new Set(onTripDrivers)];

    const availableVehicles = vehicles.filter(vehicle => vehicle.isActive && !vehicle.isInUse);
    const inUseVehicles = vehicles.filter(vehicle => vehicle.isInUse);
    const maintenanceVehicles = vehicles.filter(vehicle => vehicle.needsMaintenance);

    const completedTrips = trips.filter(trip => trip.status === TripStatus.COMPLETED);
    const inProgressTrips = trips.filter(trip => trip.status === TripStatus.IN_PROGRESS);
    const plannedTrips = trips.filter(trip => trip.status === TripStatus.PLANNED);

    return {
      drivers: {
        total: drivers.length,
        active: activeDrivers.length,
        onTrip: uniqueOnTripDrivers.length,
        utilization: drivers.length > 0 ? (uniqueOnTripDrivers.length / drivers.length) * 100 : 0,
      },
      vehicles: {
        total: vehicles.length,
        available: availableVehicles.length,
        inUse: inUseVehicles.length,
        maintenance: maintenanceVehicles.length,
        utilization: vehicles.length > 0 ? (inUseVehicles.length / vehicles.length) * 100 : 0,
      },
      trips: {
        total: trips.length,
        completed: completedTrips.length,
        inProgress: inProgressTrips.length,
        planned: plannedTrips.length,
      },
    };
  }

  async getTripAnalytics(startDate?: Date, endDate?: Date): Promise<TripAnalytics> {
    // TODO: Implement proper data fetching once findAll method is available
    let trips: Trip[] = [];

    if (startDate && endDate) {
      trips = trips.filter(trip => {
        const tripDate = new Date(trip.createdAt);
        return tripDate >= startDate && tripDate <= endDate;
      });
    }

    const completedTrips = trips.filter(trip => trip.status === TripStatus.COMPLETED);
    const onTimeTrips = completedTrips.filter(trip => {
      if (!trip.actualArrivalTime || !trip.scheduledArrivalTime) return false;
      return new Date(trip.actualArrivalTime) <= new Date(trip.scheduledArrivalTime);
    });

    const totalRevenue = trips.reduce((sum, trip) => sum + (trip.revenue || 0), 0);
    const totalFuelCost = trips.reduce((sum, trip) => sum + (trip.fuelCost || 0), 0);
    const totalOtherExpenses = trips.reduce((sum, trip) => sum + (trip.otherExpenses || 0), 0);
    const totalExpenses = totalFuelCost + totalOtherExpenses;
    const totalDistance = completedTrips.reduce((sum, trip) => sum + (trip.actualDistance || trip.plannedDistance || 0), 0);

    return {
      totalTrips: trips.length,
      completedTrips: completedTrips.length,
      totalRevenue,
      totalExpenses,
      totalProfit: totalRevenue - totalExpenses,
      averageDistance: completedTrips.length > 0 ? totalDistance / completedTrips.length : 0,
      averageRevenue: trips.length > 0 ? totalRevenue / trips.length : 0,
      onTimeDeliveryRate: completedTrips.length > 0 ? (onTimeTrips.length / completedTrips.length) * 100 : 0,
      fuelEfficiency: totalDistance > 0 && totalFuelCost > 0 ? totalDistance / (totalFuelCost / 3.5) : 0, // Assuming $3.5 per gallon
    };
  }

  async getDriverPerformance(startDate?: Date, endDate?: Date): Promise<DriverPerformance[]> {
    // TODO: Implement proper data fetching once findAll methods are available
    let trips: Trip[] = [];
    const users: User[] = [];

    if (startDate && endDate) {
      trips = trips.filter(trip => {
        const tripDate = new Date(trip.createdAt);
        return tripDate >= startDate && tripDate <= endDate;
      });
    }

    const driverStats = new Map<string, {
      driver: User;
      trips: Trip[];
      completedTrips: Trip[];
      onTimeTrips: Trip[];
    }>();

    trips.forEach(trip => {
      const driverId = trip.driverId;
      if (!driverStats.has(driverId)) {
        const driver = users.find(u => u.id === driverId);
        if (!driver) return;
        
        driverStats.set(driverId, {
          driver,
          trips: [],
          completedTrips: [],
          onTimeTrips: [],
        });
      }

      const stats = driverStats.get(driverId);
      stats.trips.push(trip);
      
      if (trip.status === TripStatus.COMPLETED) {
        stats.completedTrips.push(trip);
        if (trip.actualArrivalTime && trip.scheduledArrivalTime) {
          if (new Date(trip.actualArrivalTime) <= new Date(trip.scheduledArrivalTime)) {
            stats.onTimeTrips.push(trip);
          }
        }
      }
    });

    return Array.from(driverStats.entries()).map(([driverId, stats]) => {
      const totalDistance = stats.completedTrips.reduce((sum, trip) => sum + (trip.actualDistance || trip.plannedDistance || 0), 0);
      const totalRevenue = stats.trips.reduce((sum, trip) => sum + (trip.revenue || 0), 0);

      return {
        driverId,
        driverName: `${stats.driver.firstName} ${stats.driver.lastName}`,
        totalTrips: stats.trips.length,
        completedTrips: stats.completedTrips.length,
        totalDistance,
        totalRevenue,
        averageRevenue: stats.trips.length > 0 ? totalRevenue / stats.trips.length : 0,
        onTimeDeliveryRate: stats.completedTrips.length > 0 ? (stats.onTimeTrips.length / stats.completedTrips.length) * 100 : 0,
        utilizationRate: 0, // This would need additional logic based on available working days
      };
    });
  }

  async getVehicleUtilization(startDate?: Date, endDate?: Date): Promise<VehicleUtilization[]> {
    // TODO: Implement proper data fetching once findAll methods are available
    let trips: Trip[] = [];
    const vehicles: any[] = [];

    if (startDate && endDate) {
      trips = trips.filter(trip => {
        const tripDate = new Date(trip.createdAt);
        return tripDate >= startDate && tripDate <= endDate;
      });
    }

    const vehicleStats = new Map<string, {
      vehicle: Vehicle;
      trips: Trip[];
    }>();

    trips.forEach(trip => {
      const vehicleId = trip.vehicleId;
      if (!vehicleStats.has(vehicleId)) {
        const vehicle = vehicles.find(v => v.id === vehicleId);
        if (!vehicle) return;
        
        vehicleStats.set(vehicleId, {
          vehicle,
          trips: [],
        });
      }
      vehicleStats.get(vehicleId).trips.push(trip);
    });

    return Array.from(vehicleStats.entries()).map(([vehicleId, stats]) => {
      const totalDistance = stats.trips.reduce((sum, trip) => sum + (trip.actualDistance || trip.plannedDistance || 0), 0);
      const totalRevenue = stats.trips.reduce((sum, trip) => sum + (trip.revenue || 0), 0);
      const totalFuelCost = stats.trips.reduce((sum, trip) => sum + (trip.fuelCost || 0), 0);
      const totalOtherExpenses = stats.trips.reduce((sum, trip) => sum + (trip.otherExpenses || 0), 0);
      const totalExpenses = totalFuelCost + totalOtherExpenses;

      return {
        vehicleId,
        vehicleNumber: stats.vehicle.licensePlate || stats.vehicle.id,
        totalTrips: stats.trips.length,
        totalDistance,
        utilizationRate: 0, // This would need additional logic based on available days
        maintenanceCost: 0, // This would need maintenance records
        revenueGenerated: totalRevenue,
        profitability: totalRevenue - totalExpenses,
      };
    });
  }

  async getRevenueAnalytics(startDate?: Date, endDate?: Date) {
    // TODO: Implement proper data fetching once findAll method is available
    let trips: Trip[] = [];

    if (startDate && endDate) {
      trips = trips.filter(trip => {
        const tripDate = new Date(trip.createdAt);
        return tripDate >= startDate && tripDate <= endDate;
      });
    }

    // Group by month
    const monthlyData = new Map<string, {
      revenue: number;
      expenses: number;
      tripCount: number;
    }>();

    trips.forEach(trip => {
      const tripDate = new Date(trip.createdAt);
      const monthKey = `${tripDate.getFullYear()}-${String(tripDate.getMonth() + 1).padStart(2, '0')}`;
      
      if (!monthlyData.has(monthKey)) {
        monthlyData.set(monthKey, {
          revenue: 0,
          expenses: 0,
          tripCount: 0,
        });
      }

      const data = monthlyData.get(monthKey);
      data.revenue += trip.revenue || 0;
      data.expenses += (trip.fuelCost || 0) + (trip.otherExpenses || 0);
      data.tripCount += 1;
    });

    return Array.from(monthlyData.entries())
      .map(([month, data]) => ({
        month,
        revenue: data.revenue,
        expenses: data.expenses,
        profit: data.revenue - data.expenses,
        tripCount: data.tripCount,
      }))
      .sort((a, b) => a.month.localeCompare(b.month));
  }

  async getMaintenanceAlerts() {
    // TODO: Implement proper data fetching once findAll methods are available
    const vehicles: any[] = [];
    const users: User[] = [];

    const vehiclesNeedingMaintenance = vehicles.filter(vehicle => vehicle.needsMaintenance);
    const driversWithExpiringLicenses = users.filter(user => {
      if (user.role !== UserRole.DRIVER || !user.licenseExpiryDate) return false;
      const expiryDate = new Date(user.licenseExpiryDate);
      const thirtyDaysFromNow = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      return expiryDate <= thirtyDaysFromNow;
    });

    return {
      vehiclesNeedingMaintenance: vehiclesNeedingMaintenance.length,
      driversWithExpiringLicenses: driversWithExpiringLicenses.length,
      alerts: [
        ...vehiclesNeedingMaintenance.map(vehicle => ({
          type: 'vehicle_maintenance',
          message: `Vehicle ${vehicle.licensePlate || vehicle.id} needs maintenance`,
          severity: 'high',
          dueDate: vehicle.nextMaintenanceDate,
        })),
        ...driversWithExpiringLicenses.map(driver => ({
          type: 'license_expiry',
          message: `${driver.firstName} ${driver.lastName}'s license expires soon`,
          severity: 'medium',
          dueDate: driver.licenseExpiryDate,
        })),
      ],
    };
  }
}